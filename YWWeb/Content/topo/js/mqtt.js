"undefined" == typeof Paho && (Paho = {}), Paho.MQTT = function (e) { function t(e, t, s) { return t[s++] = e >> 8, t[s++] = e % 256, s } function s(e, s, i, o) { return o = t(s, i, o), n(e, i, o), o + s } function i(e) { for (var t = 0, s = 0; s < e.length; s++) { var i = e.charCodeAt(s); 2047 < i ? (55296 <= i && 56319 >= i && (s++, t++), t += 3) : 127 < i ? t += 2 : t++ } return t } function n(e, t, s) { for (var i = 0; i < e.length; i++) { var n = e.charCodeAt(i); if (55296 <= n && 56319 >= n) { var o = e.charCodeAt(++i); if (isNaN(o)) throw Error(d(c.MALFORMED_UNICODE, [n, o])); n = (n - 55296 << 10) + (o - 56320) + 65536 } 127 >= n ? t[s++] = n : (2047 >= n ? t[s++] = n >> 6 & 31 | 192 : (65535 >= n ? t[s++] = n >> 12 & 15 | 224 : (t[s++] = n >> 18 & 7 | 240, t[s++] = n >> 12 & 63 | 128), t[s++] = n >> 6 & 63 | 128), t[s++] = 63 & n | 128) } return t } function o(e, t, s) { for (var i, n = "", o = t; o < t + s;) { if (i = e[o++], !(128 > i)) { var r = e[o++] - 128; if (0 > r) throw Error(d(c.MALFORMED_UTF, [i.toString(16), r.toString(16), ""])); if (224 > i) i = 64 * (i - 192) + r; else { var a = e[o++] - 128; if (0 > a) throw Error(d(c.MALFORMED_UTF, [i.toString(16), r.toString(16), a.toString(16)])); if (240 > i) i = 4096 * (i - 224) + 64 * r + a; else { var h = e[o++] - 128; if (0 > h) throw Error(d(c.MALFORMED_UTF, [i.toString(16), r.toString(16), a.toString(16), h.toString(16)])); if (!(248 > i)) throw Error(d(c.MALFORMED_UTF, [i.toString(16), r.toString(16), a.toString(16), h.toString(16)])); i = 262144 * (i - 240) + 4096 * r + 64 * a + h } } } 65535 < i && (i -= 65536, n += String.fromCharCode(55296 + (i >> 10)), i = 56320 + (1023 & i)), n += String.fromCharCode(i) } return n } var r = function (e, t) { for (var s in e) if (e.hasOwnProperty(s)) { if (!t.hasOwnProperty(s)) { var i = "Unknown property, " + s + ". Valid properties are:"; for (s in t) t.hasOwnProperty(s) && (i = i + " " + s); throw Error(i) } if (typeof e[s] !== t[s]) throw Error(d(c.INVALID_TYPE, [typeof e[s], s])) } }, a = function (e, t) { return function () { return e.apply(t, arguments) } }, c = { OK: { code: 0, text: "AMQJSC0000I OK." }, CONNECT_TIMEOUT: { code: 1, text: "AMQJSC0001E Connect timed out." }, SUBSCRIBE_TIMEOUT: { code: 2, text: "AMQJS0002E Subscribe timed out." }, UNSUBSCRIBE_TIMEOUT: { code: 3, text: "AMQJS0003E Unsubscribe timed out." }, PING_TIMEOUT: { code: 4, text: "AMQJS0004E Ping timed out." }, INTERNAL_ERROR: { code: 5, text: "AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}" }, CONNACK_RETURNCODE: { code: 6, text: "AMQJS0006E Bad Connack return code:{0} {1}." }, SOCKET_ERROR: { code: 7, text: "AMQJS0007E Socket error:{0}." }, SOCKET_CLOSE: { code: 8, text: "AMQJS0008I Socket closed." }, MALFORMED_UTF: { code: 9, text: "AMQJS0009E Malformed UTF data:{0} {1} {2}." }, UNSUPPORTED: { code: 10, text: "AMQJS0010E {0} is not supported by this browser." }, INVALID_STATE: { code: 11, text: "AMQJS0011E Invalid state {0}." }, INVALID_TYPE: { code: 12, text: "AMQJS0012E Invalid type {0} for {1}." }, INVALID_ARGUMENT: { code: 13, text: "AMQJS0013E Invalid argument {0} for {1}." }, UNSUPPORTED_OPERATION: { code: 14, text: "AMQJS0014E Unsupported operation." }, INVALID_STORED_DATA: { code: 15, text: "AMQJS0015E Invalid data in local storage key={0} value={1}." }, INVALID_MQTT_MESSAGE_TYPE: { code: 16, text: "AMQJS0016E Invalid MQTT message type {0}." }, MALFORMED_UNICODE: { code: 17, text: "AMQJS0017E Malformed Unicode string:{0} {1}." } }, h = { 0: "Connection Accepted", 1: "Connection Refused: unacceptable protocol version", 2: "Connection Refused: identifier rejected", 3: "Connection Refused: server unavailable", 4: "Connection Refused: bad user name or password", 5: "Connection Refused: not authorized" }, d = function (e, t) { var s = e.text; if (t) for (var i, n, o = 0; o < t.length; o++) if (i = "{" + o + "}", n = s.indexOf(i), 0 < n) var r = s.substring(0, n), s = s.substring(n + i.length), s = r + t[o] + s; return s }, u = [0, 6, 77, 81, 73, 115, 100, 112, 3], f = [0, 4, 77, 81, 84, 84, 4], l = function (e, t) { this.type = e; for (var s in t) t.hasOwnProperty(s) && (this[s] = t[s]) }; l.prototype.encode = function () { var e = (15 & this.type) << 4, n = 0, o = [], r = 0; switch (void 0 != this.messageIdentifier && (n += 2), this.type) { case 1: switch (this.mqttVersion) { case 3: n += u.length + 3; break; case 4: n += f.length + 3 } if (n += i(this.clientId) + 2, void 0 != this.willMessage) { var n = n + (i(this.willMessage.destinationName) + 2), a = this.willMessage.payloadBytes; a instanceof Uint8Array || (a = new Uint8Array(h)), n += a.byteLength + 2 } void 0 != this.userName && (n += i(this.userName) + 2), void 0 != this.password && (n += i(this.password) + 2); break; case 8: for (var e = 2 | e, c = 0; c < this.topics.length; c++) o[c] = i(this.topics[c]), n += o[c] + 2; n += this.requestedQos.length; break; case 10: for (e |= 2, c = 0; c < this.topics.length; c++) o[c] = i(this.topics[c]), n += o[c] + 2; break; case 6: e |= 2; break; case 3: this.payloadMessage.duplicate && (e |= 8), e = e |= this.payloadMessage.qos << 1, this.payloadMessage.retained && (e |= 1); var r = i(this.payloadMessage.destinationName), h = this.payloadMessage.payloadBytes, n = n + (r + 2) + h.byteLength; h instanceof ArrayBuffer ? h = new Uint8Array(h) : h instanceof Uint8Array || (h = new Uint8Array(h.buffer)) } var d = n, c = Array(1), l = 0; do { var g = d % 128, d = d >> 7; 0 < d && (g |= 128), c[l++] = g } while (0 < d && 4 > l); if (d = c.length + 1, n = new ArrayBuffer(n + d), l = new Uint8Array(n), l[0] = e, l.set(c, 1), 3 == this.type) d = s(this.payloadMessage.destinationName, r, l, d); else if (1 == this.type) { switch (this.mqttVersion) { case 3: l.set(u, d), d += u.length; break; case 4: l.set(f, d), d += f.length } e = 0, this.cleanSession && (e = 2), void 0 != this.willMessage && (e = 4 | e | this.willMessage.qos << 3, this.willMessage.retained && (e |= 32)), void 0 != this.userName && (e |= 128), void 0 != this.password && (e |= 64), l[d++] = e, d = t(this.keepAliveInterval, l, d) } switch (void 0 != this.messageIdentifier && (d = t(this.messageIdentifier, l, d)), this.type) { case 1: d = s(this.clientId, i(this.clientId), l, d), void 0 != this.willMessage && (d = s(this.willMessage.destinationName, i(this.willMessage.destinationName), l, d), d = t(a.byteLength, l, d), l.set(a, d), d += a.byteLength), void 0 != this.userName && (d = s(this.userName, i(this.userName), l, d)), void 0 != this.password && s(this.password, i(this.password), l, d); break; case 3: l.set(h, d); break; case 8: for (c = 0; c < this.topics.length; c++) d = s(this.topics[c], o[c], l, d), l[d++] = this.requestedQos[c]; break; case 10: for (c = 0; c < this.topics.length; c++) d = s(this.topics[c], o[c], l, d) } return n }; var g = function (e, t, s) { this._client = e, this._window = t, this._keepAliveInterval = 1e3 * s, this.isReset = !1; var i = new l(12).encode(), n = function (e) { return function () { return o.apply(e) } }, o = function () { this.isReset ? (this.isReset = !1, this._client._trace("Pinger.doPing", "send PINGREQ"), this._client.socket.send(i), this.timeout = this._window.setTimeout(n(this), this._keepAliveInterval)) : (this._client._trace("Pinger.doPing", "Timed out"), this._client._disconnected(c.PING_TIMEOUT.code, d(c.PING_TIMEOUT))) }; this.reset = function () { this.isReset = !0, this._window.clearTimeout(this.timeout), 0 < this._keepAliveInterval && (this.timeout = setTimeout(n(this), this._keepAliveInterval)) }, this.cancel = function () { this._window.clearTimeout(this.timeout) } }, _ = function (e, t, s, i, n) { this._window = t, s || (s = 30), this.timeout = setTimeout(function (e, t, s) { return function () { return e.apply(t, s) } }(i, e, n), 1e3 * s), this.cancel = function () { this._window.clearTimeout(this.timeout) } }, p = function (t, s, i, n, o) { if (!("WebSocket" in e && null !== e.WebSocket)) throw Error(d(c.UNSUPPORTED, ["WebSocket"])); if (!("localStorage" in e && null !== e.localStorage)) throw Error(d(c.UNSUPPORTED, ["localStorage"])); if (!("ArrayBuffer" in e && null !== e.ArrayBuffer)) throw Error(d(c.UNSUPPORTED, ["ArrayBuffer"])); this._trace("Paho.MQTT.Client", t, s, i, n, o), this.host = s, this.port = i, this.path = n, this.uri = t, this.clientId = o, this._localKey = s + ":" + i + ("/mqtt" != n ? ":" + n : "") + ":" + o + ":", this._msg_queue = [], this._sentMessages = {}, this._receivedMessages = {}, this._notify_msg_sent = {}, this._message_identifier = 1, this._sequence = 0; for (var r in localStorage) 0 != r.indexOf("Sent:" + this._localKey) && 0 != r.indexOf("Received:" + this._localKey) || this.restore(r) }; p.prototype.host, p.prototype.port, p.prototype.path, p.prototype.uri, p.prototype.clientId, p.prototype.socket, p.prototype.connected = !1, p.prototype.maxMessageIdentifier = 65536, p.prototype.connectOptions, p.prototype.hostIndex, p.prototype.onConnectionLost, p.prototype.onMessageDelivered, p.prototype.onMessageArrived, p.prototype.traceFunction, p.prototype._msg_queue = null, p.prototype._connectTimeout, p.prototype.sendPinger = null, p.prototype.receivePinger = null, p.prototype.receiveBuffer = null, p.prototype._traceBuffer = null, p.prototype._MAX_TRACE_ENTRIES = 100, p.prototype.connect = function (e) { var t = this._traceMask(e, "password"); if (this._trace("Client.connect", t, this.socket, this.connected), this.connected) throw Error(d(c.INVALID_STATE, ["already connected"])); if (this.socket) throw Error(d(c.INVALID_STATE, ["already connected"])); this.connectOptions = e, e.uris ? (this.hostIndex = 0, this._doConnect(e.uris[0])) : this._doConnect(this.uri) }, p.prototype.subscribe = function (e, t) { if (this._trace("Client.subscribe", e, t), !this.connected) throw Error(d(c.INVALID_STATE, ["not connected"])); var s = new l(8); s.topics = [e], s.requestedQos = void 0 != t.qos ? [t.qos] : [0], t.onSuccess && (s.onSuccess = function (e) { t.onSuccess({ invocationContext: t.invocationContext, grantedQos: e }) }), t.onFailure && (s.onFailure = function (e) { t.onFailure({ invocationContext: t.invocationContext, errorCode: e }) }), t.timeout && (s.timeOut = new _(this, window, t.timeout, t.onFailure, [{ invocationContext: t.invocationContext, errorCode: c.SUBSCRIBE_TIMEOUT.code, errorMessage: d(c.SUBSCRIBE_TIMEOUT) }])), this._requires_ack(s), this._schedule_message(s) }, p.prototype.unsubscribe = function (e, t) { if (this._trace("Client.unsubscribe", e, t), !this.connected) throw Error(d(c.INVALID_STATE, ["not connected"])); var s = new l(10); s.topics = [e], t.onSuccess && (s.callback = function () { t.onSuccess({ invocationContext: t.invocationContext }) }), t.timeout && (s.timeOut = new _(this, window, t.timeout, t.onFailure, [{ invocationContext: t.invocationContext, errorCode: c.UNSUBSCRIBE_TIMEOUT.code, errorMessage: d(c.UNSUBSCRIBE_TIMEOUT) }])), this._requires_ack(s), this._schedule_message(s) }, p.prototype.send = function (e) { if (this._trace("Client.send", e), !this.connected) throw Error(d(c.INVALID_STATE, ["not connected"])); wireMessage = new l(3), wireMessage.payloadMessage = e, 0 < e.qos ? this._requires_ack(wireMessage) : this.onMessageDelivered && (this._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage)), this._schedule_message(wireMessage) }, p.prototype.disconnect = function () { if (this._trace("Client.disconnect"), !this.socket) throw Error(d(c.INVALID_STATE, ["not connecting or connected"])); wireMessage = new l(14), this._notify_msg_sent[wireMessage] = a(this._disconnected, this), this._schedule_message(wireMessage) }, p.prototype.getTraceLog = function () { if (null !== this._traceBuffer) { this._trace("Client.getTraceLog", new Date), this._trace("Client.getTraceLog in flight messages", this._sentMessages.length); for (var e in this._sentMessages) this._trace("_sentMessages ", e, this._sentMessages[e]); for (e in this._receivedMessages) this._trace("_receivedMessages ", e, this._receivedMessages[e]); return this._traceBuffer } }, p.prototype.startTrace = function () { null === this._traceBuffer && (this._traceBuffer = []), this._trace("Client.startTrace", new Date, "@VERSION@") }, p.prototype.stopTrace = function () { delete this._traceBuffer }, p.prototype._doConnect = function (e) { this.connectOptions.useSSL && (e = e.split(":"), e[0] = "wss", e = e.join(":")), this.connected = !1, this.socket = 4 > this.connectOptions.mqttVersion ? new WebSocket(e, ["mqttv3.1"]) : new WebSocket(e, ["mqtt"]), this.socket.binaryType = "arraybuffer", this.socket.onopen = a(this._on_socket_open, this), this.socket.onmessage = a(this._on_socket_message, this), this.socket.onerror = a(this._on_socket_error, this), this.socket.onclose = a(this._on_socket_close, this), this.sendPinger = new g(this, window, this.connectOptions.keepAliveInterval), this.receivePinger = new g(this, window, this.connectOptions.keepAliveInterval), this._connectTimeout = new _(this, window, this.connectOptions.timeout, this._disconnected, [c.CONNECT_TIMEOUT.code, d(c.CONNECT_TIMEOUT)]) }, p.prototype._schedule_message = function (e) { this._msg_queue.push(e), this.connected && this._process_queue() }, p.prototype.store = function (e, t) { var s = { type: t.type, messageIdentifier: t.messageIdentifier, version: 1 }; switch (t.type) { case 3: t.pubRecReceived && (s.pubRecReceived = !0), s.payloadMessage = {}; for (var i = "", n = t.payloadMessage.payloadBytes, o = 0; o < n.length; o++) i = 15 >= n[o] ? i + "0" + n[o].toString(16) : i + n[o].toString(16); s.payloadMessage.payloadHex = i, s.payloadMessage.qos = t.payloadMessage.qos, s.payloadMessage.destinationName = t.payloadMessage.destinationName, t.payloadMessage.duplicate && (s.payloadMessage.duplicate = !0), t.payloadMessage.retained && (s.payloadMessage.retained = !0), 0 == e.indexOf("Sent:") && (void 0 === t.sequence && (t.sequence = ++this._sequence), s.sequence = t.sequence); break; default: throw Error(d(c.INVALID_STORED_DATA, [key, s])) } localStorage.setItem(e + this._localKey + t.messageIdentifier, JSON.stringify(s)) }, p.prototype.restore = function (e) { var t = localStorage.getItem(e), s = JSON.parse(t), i = new l(s.type, s); switch (s.type) { case 3: for (var t = s.payloadMessage.payloadHex, n = new ArrayBuffer(t.length / 2), n = new Uint8Array(n), o = 0; 2 <= t.length;) { var r = parseInt(t.substring(0, 2), 16), t = t.substring(2, t.length); n[o++] = r } t = new Paho.MQTT.Message(n), t.qos = s.payloadMessage.qos, t.destinationName = s.payloadMessage.destinationName, s.payloadMessage.duplicate && (t.duplicate = !0), s.payloadMessage.retained && (t.retained = !0), i.payloadMessage = t; break; default: throw Error(d(c.INVALID_STORED_DATA, [e, t])) } 0 == e.indexOf("Sent:" + this._localKey) ? (i.payloadMessage.duplicate = !0, this._sentMessages[i.messageIdentifier] = i) : 0 == e.indexOf("Received:" + this._localKey) && (this._receivedMessages[i.messageIdentifier] = i) }, p.prototype._process_queue = function () { for (var e = null, t = this._msg_queue.reverse() ; e = t.pop() ;) this._socket_send(e), this._notify_msg_sent[e] && (this._notify_msg_sent[e](), delete this._notify_msg_sent[e]) }, p.prototype._requires_ack = function (e) { var t = Object.keys(this._sentMessages).length; if (t > this.maxMessageIdentifier) throw Error("Too many messages:" + t); for (; void 0 !== this._sentMessages[this._message_identifier];) this._message_identifier++; e.messageIdentifier = this._message_identifier, this._sentMessages[e.messageIdentifier] = e, 3 === e.type && this.store("Sent:", e), this._message_identifier === this.maxMessageIdentifier && (this._message_identifier = 1) }, p.prototype._on_socket_open = function () { var e = new l(1, this.connectOptions); e.clientId = this.clientId, this._socket_send(e) }, p.prototype._on_socket_message = function (e) { this._trace("Client._on_socket_message", e.data), this.receivePinger.reset(), e = this._deframeMessages(e.data); for (var t = 0; t < e.length; t += 1) this._handleMessage(e[t]) }, p.prototype._deframeMessages = function (e) { if (e = new Uint8Array(e), this.receiveBuffer) { var t = new Uint8Array(this.receiveBuffer.length + e.length); t.set(this.receiveBuffer), t.set(e, this.receiveBuffer.length), e = t, delete this.receiveBuffer } try { for (var t = 0, s = []; t < e.length;) { var i; e: { var n = e, r = t, a = r, h = n[r], u = h >> 4, f = 15 & h, r = r + 1, g = void 0, _ = 0, p = 1; do { if (r == n.length) { i = [null, a]; break e } g = n[r++], _ += (127 & g) * p, p *= 128 } while (0 != (128 & g)); if (g = r + _, g > n.length) i = [null, a]; else { var y = new l(u); switch (u) { case 2: 1 & n[r++] && (y.sessionPresent = !0), y.returnCode = n[r++]; break; case 3: var a = f >> 1 & 3, I = 256 * n[r] + n[r + 1], r = r + 2, M = o(n, r, I), r = r + I; 0 < a && (y.messageIdentifier = 256 * n[r] + n[r + 1], r += 2); var v = new Paho.MQTT.Message(n.subarray(r, g)); 1 == (1 & f) && (v.retained = !0), 8 == (8 & f) && (v.duplicate = !0), v.qos = a, v.destinationName = M, y.payloadMessage = v; break; case 4: case 5: case 6: case 7: case 11: y.messageIdentifier = 256 * n[r] + n[r + 1]; break; case 9: y.messageIdentifier = 256 * n[r] + n[r + 1], r += 2, y.returnCode = n.subarray(r, g) } i = [y, g] } } var E = i[0], t = i[1]; if (null === E) break; s.push(E) } t < e.length && (this.receiveBuffer = e.subarray(t)) } catch (e) { return void this._disconnected(c.INTERNAL_ERROR.code, d(c.INTERNAL_ERROR, [e.message, e.stack.toString()])) } return s }, p.prototype._handleMessage = function (e) { this._trace("Client._handleMessage", e); try { switch (e.type) { case 2: if (this._connectTimeout.cancel(), this.connectOptions.cleanSession) { for (var t in this._sentMessages) { var s = this._sentMessages[t]; localStorage.removeItem("Sent:" + this._localKey + s.messageIdentifier) } this._sentMessages = {}; for (t in this._receivedMessages) { var i = this._receivedMessages[t]; localStorage.removeItem("Received:" + this._localKey + i.messageIdentifier) } this._receivedMessages = {} } if (0 !== e.returnCode) { this._disconnected(c.CONNACK_RETURNCODE.code, d(c.CONNACK_RETURNCODE, [e.returnCode, h[e.returnCode]])); break } this.connected = !0, this.connectOptions.uris && (this.hostIndex = this.connectOptions.uris.length), e = []; for (var n in this._sentMessages) this._sentMessages.hasOwnProperty(n) && e.push(this._sentMessages[n]); e = e.sort(function (e, t) { return e.sequence - t.sequence }), n = 0; for (var o = e.length; n < o; n++) if (s = e[n], 3 == s.type && s.pubRecReceived) { var r = new l(6, { messageIdentifier: s.messageIdentifier }); this._schedule_message(r) } else this._schedule_message(s); this.connectOptions.onSuccess && this.connectOptions.onSuccess({ invocationContext: this.connectOptions.invocationContext }), this._process_queue(); break; case 3: this._receivePublish(e); break; case 4: (s = this._sentMessages[e.messageIdentifier]) && (delete this._sentMessages[e.messageIdentifier], localStorage.removeItem("Sent:" + this._localKey + e.messageIdentifier), this.onMessageDelivered && this.onMessageDelivered(s.payloadMessage)); break; case 5: (s = this._sentMessages[e.messageIdentifier]) && (s.pubRecReceived = !0, r = new l(6, { messageIdentifier: e.messageIdentifier }), this.store("Sent:", s), this._schedule_message(r)); break; case 6: i = this._receivedMessages[e.messageIdentifier], localStorage.removeItem("Received:" + this._localKey + e.messageIdentifier), i && (this._receiveMessage(i), delete this._receivedMessages[e.messageIdentifier]); var a = new l(7, { messageIdentifier: e.messageIdentifier }); this._schedule_message(a); break; case 7: s = this._sentMessages[e.messageIdentifier], delete this._sentMessages[e.messageIdentifier], localStorage.removeItem("Sent:" + this._localKey + e.messageIdentifier), this.onMessageDelivered && this.onMessageDelivered(s.payloadMessage); break; case 9: (s = this._sentMessages[e.messageIdentifier]) && (s.timeOut && s.timeOut.cancel(), e.returnCode.indexOf = Array.prototype.indexOf, -1 !== e.returnCode.indexOf(128) ? s.onFailure && s.onFailure(e.returnCode) : s.onSuccess && s.onSuccess(e.returnCode), delete this._sentMessages[e.messageIdentifier]); break; case 11: (s = this._sentMessages[e.messageIdentifier]) && (s.timeOut && s.timeOut.cancel(), s.callback && s.callback(), delete this._sentMessages[e.messageIdentifier]); break; case 13: this.sendPinger.reset(); break; case 14: this._disconnected(c.INVALID_MQTT_MESSAGE_TYPE.code, d(c.INVALID_MQTT_MESSAGE_TYPE, [e.type])); break; default: this._disconnected(c.INVALID_MQTT_MESSAGE_TYPE.code, d(c.INVALID_MQTT_MESSAGE_TYPE, [e.type])) } } catch (e) { this._disconnected(c.INTERNAL_ERROR.code, d(c.INTERNAL_ERROR, [e.message, e.stack.toString()])) } }, p.prototype._on_socket_error = function (e) { this._disconnected(c.SOCKET_ERROR.code, d(c.SOCKET_ERROR, [e.data])) }, p.prototype._on_socket_close = function () { this._disconnected(c.SOCKET_CLOSE.code, d(c.SOCKET_CLOSE)) }, p.prototype._socket_send = function (e) { if (1 == e.type) { var t = this._traceMask(e, "password"); this._trace("Client._socket_send", t) } else this._trace("Client._socket_send", e); this.socket.send(e.encode()), this.sendPinger.reset() }, p.prototype._receivePublish = function (e) { switch (e.payloadMessage.qos) { case "undefined": case 0: this._receiveMessage(e); break; case 1: var t = new l(4, { messageIdentifier: e.messageIdentifier }); this._schedule_message(t), this._receiveMessage(e); break; case 2: this._receivedMessages[e.messageIdentifier] = e, this.store("Received:", e), e = new l(5, { messageIdentifier: e.messageIdentifier }), this._schedule_message(e); break; default: throw Error("Invaild qos=" + wireMmessage.payloadMessage.qos) } }, p.prototype._receiveMessage = function (e) { this.onMessageArrived && this.onMessageArrived(e.payloadMessage) }, p.prototype._disconnected = function (e, t) { this._trace("Client._disconnected", e, t), this.sendPinger.cancel(), this.receivePinger.cancel(), this._connectTimeout && this._connectTimeout.cancel(), this._msg_queue = [], this._notify_msg_sent = {}, this.socket && (this.socket.onopen = null, this.socket.onmessage = null, this.socket.onerror = null, this.socket.onclose = null, 1 === this.socket.readyState && this.socket.close(), delete this.socket), this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1 ? (this.hostIndex++, this._doConnect(this.connectOptions.uris[this.hostIndex])) : (void 0 === e && (e = c.OK.code, t = d(c.OK)), this.connected ? (this.connected = !1, this.onConnectionLost && this.onConnectionLost({ errorCode: e, errorMessage: t })) : 4 === this.connectOptions.mqttVersion && !1 === this.connectOptions.mqttVersionExplicit ? (this._trace("Failed to connect V4, dropping back to V3"), this.connectOptions.mqttVersion = 3, this.connectOptions.uris ? (this.hostIndex = 0, this._doConnect(this.connectOptions.uris[0])) : this._doConnect(this.uri)) : this.connectOptions.onFailure && this.connectOptions.onFailure({ invocationContext: this.connectOptions.invocationContext, errorCode: e, errorMessage: t })) }, p.prototype._trace = function () { if (this.traceFunction) { for (var e in arguments) "undefined" != typeof arguments[e] && (arguments[e] = JSON.stringify(arguments[e])); e = Array.prototype.slice.call(arguments).join(""), this.traceFunction({ severity: "Debug", message: e }) } if (null !== this._traceBuffer) { e = 0; for (var t = arguments.length; e < t; e++) this._traceBuffer.length == this._MAX_TRACE_ENTRIES && this._traceBuffer.shift(), 0 === e ? this._traceBuffer.push(arguments[e]) : "undefined" == typeof arguments[e] ? this._traceBuffer.push(arguments[e]) : this._traceBuffer.push("  " + JSON.stringify(arguments[e])) } }, p.prototype._traceMask = function (e, t) { var s, i = {}; for (s in e) e.hasOwnProperty(s) && (i[s] = s == t ? "******" : e[s]); return i }; var y = function (e, t, s, i) { var n; if ("string" != typeof e) throw Error(d(c.INVALID_TYPE, [typeof e, "host"])); if (2 == arguments.length) { i = t, n = e; var o = n.match(/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/); if (!o) throw Error(d(c.INVALID_ARGUMENT, [e, "host"])); e = o[4] || o[2], t = parseInt(o[7]), s = o[8] } else { if (3 == arguments.length && (i = s, s = "/mqtt"), "number" != typeof t || 0 > t) throw Error(d(c.INVALID_TYPE, [typeof t, "port"])); if ("string" != typeof s) throw Error(d(c.INVALID_TYPE, [typeof s, "path"])); n = "ws://" + (-1 != e.indexOf(":") && "[" != e.slice(0, 1) && "]" != e.slice(-1) ? "[" + e + "]" : e) + ":" + t + s } for (var a = o = 0; a < i.length; a++) { var h = i.charCodeAt(a); 55296 <= h && 56319 >= h && a++, o++ } if ("string" != typeof i || 65535 < o) throw Error(d(c.INVALID_ARGUMENT, [i, "clientId"])); var u = new p(n, e, t, s, i); this._getHost = function () { return e }, this._setHost = function () { throw Error(d(c.UNSUPPORTED_OPERATION)) }, this._getPort = function () { return t }, this._setPort = function () { throw Error(d(c.UNSUPPORTED_OPERATION)) }, this._getPath = function () { return s }, this._setPath = function () { throw Error(d(c.UNSUPPORTED_OPERATION)) }, this._getURI = function () { return n }, this._setURI = function () { throw Error(d(c.UNSUPPORTED_OPERATION)) }, this._getClientId = function () { return u.clientId }, this._setClientId = function () { throw Error(d(c.UNSUPPORTED_OPERATION)) }, this._getOnConnectionLost = function () { return u.onConnectionLost }, this._setOnConnectionLost = function (e) { if ("function" != typeof e) throw Error(d(c.INVALID_TYPE, [typeof e, "onConnectionLost"])); u.onConnectionLost = e }, this._getOnMessageDelivered = function () { return u.onMessageDelivered }, this._setOnMessageDelivered = function (e) { if ("function" != typeof e) throw Error(d(c.INVALID_TYPE, [typeof e, "onMessageDelivered"])); u.onMessageDelivered = e }, this._getOnMessageArrived = function () { return u.onMessageArrived }, this._setOnMessageArrived = function (e) { if ("function" != typeof e) throw Error(d(c.INVALID_TYPE, [typeof e, "onMessageArrived"])); u.onMessageArrived = e }, this._getTrace = function () { return u.traceFunction }, this._setTrace = function (e) { if ("function" != typeof e) throw Error(d(c.INVALID_TYPE, [typeof e, "onTrace"])); u.traceFunction = e }, this.connect = function (e) { if (e = e || {}, r(e, { timeout: "number", userName: "string", password: "string", willMessage: "object", keepAliveInterval: "number", cleanSession: "boolean", useSSL: "boolean", invocationContext: "object", onSuccess: "function", onFailure: "function", hosts: "object", ports: "object", mqttVersion: "number" }), void 0 === e.keepAliveInterval && (e.keepAliveInterval = 60), 4 < e.mqttVersion || 3 > e.mqttVersion) throw Error(d(c.INVALID_ARGUMENT, [e.mqttVersion, "connectOptions.mqttVersion"])); if (void 0 === e.mqttVersion ? (e.mqttVersionExplicit = !1, e.mqttVersion = 4) : e.mqttVersionExplicit = !0, void 0 === e.password && void 0 !== e.userName) throw Error(d(c.INVALID_ARGUMENT, [e.password, "connectOptions.password"])); if (e.willMessage) { if (!(e.willMessage instanceof I)) throw Error(d(c.INVALID_TYPE, [e.willMessage, "connectOptions.willMessage"])); if (e.willMessage.stringPayload, "undefined" == typeof e.willMessage.destinationName) throw Error(d(c.INVALID_TYPE, [typeof e.willMessage.destinationName, "connectOptions.willMessage.destinationName"])) } if ("undefined" == typeof e.cleanSession && (e.cleanSession = !0), e.hosts) { if (!(e.hosts instanceof Array)) throw Error(d(c.INVALID_ARGUMENT, [e.hosts, "connectOptions.hosts"])); if (1 > e.hosts.length) throw Error(d(c.INVALID_ARGUMENT, [e.hosts, "connectOptions.hosts"])); for (var t = !1, i = 0; i < e.hosts.length; i++) { if ("string" != typeof e.hosts[i]) throw Error(d(c.INVALID_TYPE, [typeof e.hosts[i], "connectOptions.hosts[" + i + "]"])); if (/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/.test(e.hosts[i])) { if (0 == i) t = !0; else if (!t) throw Error(d(c.INVALID_ARGUMENT, [e.hosts[i], "connectOptions.hosts[" + i + "]"])) } else if (t) throw Error(d(c.INVALID_ARGUMENT, [e.hosts[i], "connectOptions.hosts[" + i + "]"])) } if (t) e.uris = e.hosts; else { if (!e.ports) throw Error(d(c.INVALID_ARGUMENT, [e.ports, "connectOptions.ports"])); if (!(e.ports instanceof Array)) throw Error(d(c.INVALID_ARGUMENT, [e.ports, "connectOptions.ports"])); if (e.hosts.length != e.ports.length) throw Error(d(c.INVALID_ARGUMENT, [e.ports, "connectOptions.ports"])); for (e.uris = [], i = 0; i < e.hosts.length; i++) { if ("number" != typeof e.ports[i] || 0 > e.ports[i]) throw Error(d(c.INVALID_TYPE, [typeof e.ports[i], "connectOptions.ports[" + i + "]"])); var t = e.hosts[i], o = e.ports[i]; n = "ws://" + (-1 != t.indexOf(":") ? "[" + t + "]" : t) + ":" + o + s, e.uris.push(n) } } } u.connect(e) }, this.subscribe = function (e, t) { if ("string" != typeof e) throw Error("Invalid argument:" + e); if (t = t || {}, r(t, { qos: "number", invocationContext: "object", onSuccess: "function", onFailure: "function", timeout: "number" }), t.timeout && !t.onFailure) throw Error("subscribeOptions.timeout specified with no onFailure callback."); if ("undefined" != typeof t.qos && 0 !== t.qos && 1 !== t.qos && 2 !== t.qos) throw Error(d(c.INVALID_ARGUMENT, [t.qos, "subscribeOptions.qos"])); u.subscribe(e, t) }, this.unsubscribe = function (e, t) { if ("string" != typeof e) throw Error("Invalid argument:" + e); if (t = t || {}, r(t, { invocationContext: "object", onSuccess: "function", onFailure: "function", timeout: "number" }), t.timeout && !t.onFailure) throw Error("unsubscribeOptions.timeout specified with no onFailure callback."); u.unsubscribe(e, t) }, this.send = function (e, t, s, i) { var n; if (0 == arguments.length) throw Error("Invalid argument.length"); if (1 == arguments.length) { if (!(e instanceof I) && "string" != typeof e) throw Error("Invalid argument:" + typeof e); if (n = e, "undefined" == typeof n.destinationName) throw Error(d(c.INVALID_ARGUMENT, [n.destinationName, "Message.destinationName"])) } else n = new I(t), n.destinationName = e, 3 <= arguments.length && (n.qos = s), 4 <= arguments.length && (n.retained = i); u.send(n) }, this.disconnect = function () { u.disconnect() }, this.getTraceLog = function () { return u.getTraceLog() }, this.startTrace = function () { u.startTrace() }, this.stopTrace = function () { u.stopTrace() }, this.isConnected = function () { return u.connected } }; y.prototype = { get host() { return this._getHost() }, set host(e) { this._setHost(e) }, get port() { return this._getPort() }, set port(e) { this._setPort(e) }, get path() { return this._getPath() }, set path(e) { this._setPath(e) }, get clientId() { return this._getClientId() }, set clientId(e) { this._setClientId(e) }, get onConnectionLost() { return this._getOnConnectionLost() }, set onConnectionLost(e) { this._setOnConnectionLost(e) }, get onMessageDelivered() { return this._getOnMessageDelivered() }, set onMessageDelivered(e) { this._setOnMessageDelivered(e) }, get onMessageArrived() { return this._getOnMessageArrived() }, set onMessageArrived(e) { this._setOnMessageArrived(e) }, get trace() { return this._getTrace() }, set trace(e) { this._setTrace(e) } }; var I = function (e) { var t; if (!("string" == typeof e || e instanceof ArrayBuffer || e instanceof Int8Array || e instanceof Uint8Array || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array)) throw d(c.INVALID_ARGUMENT, [e, "newPayload"]); t = e, this._getPayloadString = function () { return "string" == typeof t ? t : o(t, 0, t.length) }, this._getPayloadBytes = function () { if ("string" == typeof t) { var e = new ArrayBuffer(i(t)), e = new Uint8Array(e); return n(t, e, 0), e } return t }; var s = void 0; this._getDestinationName = function () { return s }, this._setDestinationName = function (e) { if ("string" != typeof e) throw Error(d(c.INVALID_ARGUMENT, [e, "newDestinationName"])); s = e }; var r = 0; this._getQos = function () { return r }, this._setQos = function (e) { if (0 !== e && 1 !== e && 2 !== e) throw Error("Invalid argument:" + e); r = e }; var a = !1; this._getRetained = function () { return a }, this._setRetained = function (e) { if ("boolean" != typeof e) throw Error(d(c.INVALID_ARGUMENT, [e, "newRetained"])); a = e }; var h = !1; this._getDuplicate = function () { return h }, this._setDuplicate = function (e) { h = e } }; return I.prototype = { get payloadString() { return this._getPayloadString() }, get payloadBytes() { return this._getPayloadBytes() }, get destinationName() { return this._getDestinationName() }, set destinationName(e) { this._setDestinationName(e) }, get qos() { return this._getQos() }, set qos(e) { this._setQos(e) }, get retained() { return this._getRetained() }, set retained(e) { this._setRetained(e) }, get duplicate() { return this._getDuplicate() }, set duplicate(e) { this._setDuplicate(e) } }, { Client: y, Message: I } }(window);